Only in ./: firmware.hex
File ./.git is a regular file while file ../../3-github/FL-M32_Remote_Controller/.git is a directory
Only in ./: log
diff -r ./Makefile ../../3-github/FL-M32_Remote_Controller/Makefile
0a1,2
> # Compatiable with DP4C
> DP4C			= 0
2c4,8
< CONF_LOOP_WR	= $(shell expr $(RAM_SIZE_KB) \* 4)
---
> ifeq (${DP4C}, 1)
> 	CONF_LOOP_WR= $(shell expr $(RAM_SIZE_KB) \* 4 )
> else
> 	CONF_LOOP_WR= $(shell expr $(RAM_SIZE_KB) )
> endif
7d12
< 	gcc -o t_recv recvPacket.c receiver_test.c -lpcap
12d16
< 	rm t_recv
15a20
> 	@echo "You can use 'make DP4C=1' to be compatiable with DP4C."
Only in ./: receiver_test.c
Only in ./: recvPacket.c
Only in ./: result.cap
diff -r ./sender_test.c ../../3-github/FL-M32_Remote_Controller/sender_test.c
1c1
< #include "send_recv.h"
---
> #include "send.h"
4,6c4
< // #define CONF_LOOP_WR 1024
< // #define CONF_LOOP_WR 512, which gets from Makefile;
< // #define CONF_LOOP_RD CONF_LOOP_WR*50
---
> // #define CONF_LOOP_WR 256, which gets from Makefile;
25c23
< 		printf("\tNote:\tcurrent RAM size is %d KB\n",CONF_LOOP_WR/4);
---
> 		printf("\tNote:\tcurrent RAM size is %d KB\n",CONF_LOOP_WR);
31,32c29,34
< 				//set_read_sel(0, 0);
< 				set_read_sel(0, 14);
---
> 			//* start PE_0;
> 			set_read_sel(0, 14);
> 			//* start all PEs;
> 			// set_read_sel(0, 0);
> 			//* start 2 PEs;
> 			// set_read_sel(0, 12);
35,43c37
< 			#ifdef MULTI_CORE
< 				int bitmap;
< 				printf("status of pe in bitmap is: (0 is running)");
< 				scanf("%d", &bitmap);
< 
< 				set_read_sel(0, bitmap);
< 			#else
< 				set_read_sel(0, 15);
< 			#endif
---
> 			set_read_sel(0, 15);
51c45,49
< 				lineNum = 64*i;
---
> 				#if(DP4C==1)
> 					lineNum = 64*i;
> 				#else
> 					lineNum = 256*i;
> 				#endif
54a53
> 	#if(DP4C==1)
72c71,72
< 		if(opt == 6){
---
> 	#endif
> 		else if(opt == 6){
Only in ../../3-github/FL-M32_Remote_Controller/: send.h
diff -r ./sendPacket.c ../../3-github/FL-M32_Remote_Controller/sendPacket.c
1c1
< #include "send_recv.h"
---
> #include "send.h"
13,14c13,15
< 	lib_net = libnet_init(LIBNET_LINK_ADV, "eno1", err_buf);
< //	lib_net = libnet_init(LIBNET_LINK_ADV, "enx00e04d6da7b3", err_buf);
---
> //	lib_net = libnet_init(LIBNET_LINK_ADV, "enp0s3", err_buf);
> 	lib_net = libnet_init(LIBNET_LINK_ADV, "wlp0s20f3", err_buf);
> 	// lib_net = libnet_init(LIBNET_LINK_ADV, "enx00e04d6da7b3", err_buf);
46,69c47,59
< void set_read_sel(int read, u32 value){
< 	struct send_ctx *sendCtx;
< 	sendCtx                     = (struct send_ctx *)malloc(sizeof(struct send_ctx));
<     sendCtx->type               = 0x9005;
< 	struct one_128b *one128b    = &(sendCtx->payload.one128b[0]);
< 	if(read == 1)
< 		one128b->conf_type[0]   = htons(2);
< 	else
< 		one128b->conf_type[0]   = htons(1);
<     one128b->conf_type[1]       = one128b->conf_type[0];
< 	one128b->pad                = htonl(0);
< 	one128b->tcm_data           = htonl(0);
< 	one128b->addr               = htonl(value);
< 	sendCtx->lens               = 50;
< 
< 	send_packet(sendCtx);
< 
< }
< 
< void write_tcm(char *fileName, int lineNum){
< 	FILE * fp;
< 	if((fp = fopen(fileName,"r")) == NULL){
< 		perror("fail to read");
< 		exit (1) ;
---
> #if(DP4C==1)
> 	void read_tcm(int lineNum){
> 		struct send_ctx *sendCtx;
> 		sendCtx = (struct send_ctx *)malloc(sizeof(struct send_ctx));
> 		struct one_128b *one128b = &(sendCtx->payload.one128b[0]);
> 		one128b->pad            = htonl(0);
> 		one128b->tcm_data       = htonl(0);
> 		one128b->addr           = htonl(lineNum);
> 	    one128b->conf_type[0]   = htons(4);
> 	    one128b->conf_type[1]   = one128b->conf_type[0];
> 		sendCtx->type           = 0x9005;
> 		sendCtx->lens           = 50;
> 		send_packet(sendCtx);
72,75c62,93
< 	u32	data;
< 	int i;
< 	for(i=0; i<lineNum; i++){
< 		fscanf(fp,"%08x\n", &data);
---
> 	void open_backPressure(int value){
> 	    struct send_ctx *sendCtx;
> 		sendCtx                     = (struct send_ctx *)malloc(sizeof(struct send_ctx));
> 	    sendCtx->type               = 0x9005;
> 		struct one_128b *one128b    = &(sendCtx->payload.one128b[0]);
> 		value                       = (value << 8) + 6;
> 	    one128b->conf_type[0]       = htons(value);
> 	    one128b->conf_type[1]       = one128b->conf_type[0];
> 		one128b->pad                = htonl(0);
> 		one128b->tcm_data           = htonl(0);
> 		one128b->addr               = htonl(0);
> 		sendCtx->lens               = 50;
> 
> 		send_packet(sendCtx);
> 	}
> 	#else
> 	void set_read_sel(int read, u32 value){
> 		struct send_ctx *sendCtx;
> 		sendCtx                 = (struct send_ctx *)malloc(sizeof(struct send_ctx));
> 		struct context *payload;
> 		payload             	= &(sendCtx->payload);
> 		if(read == 1)
> 			payload->conf_type 	= htons(2);
> 		else
> 			payload->conf_type 	= htons(1);
> 		payload->check_sum		= 0;
> 		payload->pad[0]			= 0;
> 		payload->pad[1]			= 0;
> 		payload->tcm_addr 		= 0;
> 		sendCtx->type           = 0x9005;
> 		sendCtx->lens           = 50;
> 		send_packet(sendCtx);
78,89c96,127
< 	struct send_ctx *sendCtx;
< 	sendCtx = (struct send_ctx *)malloc(sizeof(struct send_ctx));
< 	struct one_128b *one128b;
< 	for (i=0; i<64; i++){
< 		
< 		fscanf(fp,"%08x\n", &data);
< 		one128b             = &(sendCtx->payload.one128b[i]);
< 		one128b->pad        = htonl(0);
<     		one128b->conf_type[0]   = htons(3);
<     		one128b->conf_type[1]   = one128b->conf_type[0];
< 		one128b->tcm_data   = htonl(data);
< 		one128b->addr       = htonl(lineNum+i);
---
> 	void write_tcm(char *fileName, int lineNum){
> 		FILE * fp;
> 		if((fp = fopen(fileName,"r")) == NULL){
> 			perror("fail to read");
> 			exit (1) ;
> 		}
> 
> 		u32	data;
> 		int i;
> 		for(i=0; i<lineNum; i++){
> 			fscanf(fp,"%08x\n", &data);
> 		}
> 
> 		struct send_ctx *sendCtx;
> 		sendCtx = (struct send_ctx *)malloc(sizeof(struct send_ctx));
> 		struct context *payload;
> 		payload             	= &(sendCtx->payload);
> 		payload->conf_type   	= htons(3);
> 		payload->check_sum		= 0;
> 		payload->pad[0]			= 0;
> 		payload->pad[1]			= 0;
> 		payload->tcm_addr 		= htons(lineNum);
> 		for (i=0; i<256; i++){
> 			fscanf(fp,"%08x\n", &data);
> 			payload->tcm_data[i]= htonl(data);
> 		}
> 	    
> 		sendCtx->type           = 0x9005;
> 		sendCtx->lens           = 1024 + 16;
> 		send_packet(sendCtx);
> 
> 		fclose(fp);
91,223c129,131
<     
< 	sendCtx->type           = 0x9005;
< 	sendCtx->lens           = 1024;
< 	send_packet(sendCtx);
< 
< 	fclose(fp);
< }
< 
< 
< 
< void read_tcm(int lineNum){
< 	struct send_ctx *sendCtx;
< 	sendCtx = (struct send_ctx *)malloc(sizeof(struct send_ctx));
< 	struct one_128b *one128b = &(sendCtx->payload.one128b[0]);
< 	one128b->pad            = htonl(0);
< 	one128b->tcm_data       = htonl(0);
< 	one128b->addr           = htonl(lineNum);
<     one128b->conf_type[0]   = htons(4);
<     one128b->conf_type[1]   = one128b->conf_type[0];
< 	sendCtx->type           = 0x9005;
< 	sendCtx->lens           = 50;
< 	send_packet(sendCtx);
< }
< 
< void open_backPressure(int value){
<     struct send_ctx *sendCtx;
< 	sendCtx                     = (struct send_ctx *)malloc(sizeof(struct send_ctx));
<     sendCtx->type               = 0x9005;
< 	struct one_128b *one128b    = &(sendCtx->payload.one128b[0]);
< 	value                       = (value << 8) + 6;
<     one128b->conf_type[0]       = htons(value);
<     one128b->conf_type[1]       = one128b->conf_type[0];
< 	one128b->pad                = htonl(0);
< 	one128b->tcm_data           = htonl(0);
< 	one128b->addr               = htonl(0);
< 	sendCtx->lens               = 50;
< 
< 	send_packet(sendCtx);
< }
< 
< void send_tcp_pkt(){
<     libnet_t *handle; /* Libnet句柄 */
<     int packet_size; /* 构造的数据包大小 */
<     char *device = "eno1"; /* 设备名字,也支持点十进制的IP地址,会自己找到匹配的设备 */
<     char *src_ip_str = "192.168.2.148"; /* 源IP地址字符串 */
<     char *dst_ip_str = "192.168.2.170"; /* 目的IP地址字符串 */
<     u_char src_mac[6] = {0x00, 0x0c, 0x29, 0xba, 0xee, 0xdd}; /* 源MAC */
<     u_char dst_mac[6] = {0x00, 0x0c, 0x29, 0x6d, 0x4d, 0x5c}; /* 目的MAC */
<     u_long dst_ip, src_ip; /* 网路序的目的IP和源IP */
<     char error[LIBNET_ERRBUF_SIZE]; /* 出错信息 */
<     libnet_ptag_t eth_tag, ip_tag, tcp_tag, tcp_op_tag; /* 各层build函数返回值 */
<     u_short proto = IPPROTO_TCP; /* 传输层协议 */
<     u_char payload[255] = {0}; /* 承载数据的数组，初值为空 */
<     u_long payload_s = 0; /* 承载数据的长度，初值为0 */
<  
<     /* 把目的IP地址字符串转化成网络序 */
<     dst_ip = libnet_name2addr4(handle, dst_ip_str, LIBNET_RESOLVE);
<     /* 把源IP地址字符串转化成网络序 */
<     src_ip = libnet_name2addr4(handle, src_ip_str, LIBNET_RESOLVE);
<  
<     /* 初始化Libnet */
<     if ( (handle = libnet_init(LIBNET_LINK, device, error)) == NULL ) {
<         printf("libnet_init failure\n");
<         exit;
<     }
<  
<     strncpy(payload, "test", sizeof(payload)-1); /* 构造负载的内容 */
<     payload_s = strlen(payload); /* 计算负载内容的长度 */
<  
<  
<     tcp_tag = libnet_build_tcp(
<                 30330,                    /* 源端口 */
<                 30331,                    /* 目的端口 */
<                 8888,                    /* 序列号 */
<                 8889,                    /* 确认号 */
<                 TH_PUSH | TH_ACK,        /* Control flags */
<                 14600,                    /* 窗口尺寸 */
<                 0,                        /* 校验和,0为自动计算 */
<                 0,                        /* 紧急指针 */
<                 LIBNET_TCP_H + payload_s, /* 长度 */
<                 payload,                    /* 负载内容 */
<                 payload_s,                /* 负载内容长度 */
<                 handle,                    /* libnet句柄 */
<                 0                        /* 新建包 */
<     );
<     if (tcp_tag == -1) {
<         printf("libnet_build_tcp failure\n");
<         exit;
<     }
<  
<     /* 构造IP协议块，返回值是新生成的IP协议快的一个标记 */
<     ip_tag = libnet_build_ipv4(
<         LIBNET_IPV4_H + LIBNET_TCP_H + payload_s, /* IP协议块的总长,*/
<         0, /* tos */
<         (u_short) libnet_get_prand(LIBNET_PRu16), /* id,随机产生0~65535 */
<         0, /* frag 片偏移 */
<         (u_int8_t)libnet_get_prand(LIBNET_PR8), /* ttl,随机产生0~255 */
<         proto, /* 上层协议 */
<         0, /* 校验和，此时为0，表示由Libnet自动计算 */
<         src_ip, /* 源IP地址,网络序 */
<         dst_ip, /* 目标IP地址,网络序 */
<         NULL, /* 负载内容或为NULL */
<         0, /* 负载内容的大小*/
<         handle, /* Libnet句柄 */
<         0 /* 协议块标记可修改或创建,0表示构造一个新的*/
<     );
<     if (ip_tag == -1) {
<         printf("libnet_build_ipv4 failure\n");
<        	exit;
<     }
<  
<     /* 构造一个以太网协议块,只能用于LIBNET_LINK */
<     eth_tag = libnet_build_ethernet(
<         dst_mac, /* 以太网目的地址 */
<         src_mac, /* 以太网源地址 */
<         ETHERTYPE_IP, /* 以太网上层协议类型，此时为IP类型 */
<         NULL, /* 负载，这里为空 */ 
<         0, /* 负载大小 */
<         handle, /* Libnet句柄 */
<         0 /* 协议块标记，0表示构造一个新的 */ 
<     );
<     if (eth_tag == -1) {
<         printf("libnet_build_ethernet failure\n");
<         exit;
<     }
<  
<     packet_size = libnet_write(handle); /* 发送已经构造的数据包*/
<  
<     libnet_destroy(handle); /* 释放句柄 */
< 
<     printf("success\n");
<  
< }
---
> #endif
> 
> 
Only in ./: send_recv.h
Only in ./: t_recv
Binary files ./t_send and ../../3-github/FL-M32_Remote_Controller/t_send differ
